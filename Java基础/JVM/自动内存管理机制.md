# 						自动内存管理机制

## 一、Java内存区域与内存异常

###1、数据区域

* 程序计数器：线程私有，当前线程执行字节码行号，用于线程切换

* Java虚拟机栈：线程私有，每执行一个方法时，就会创建栈帧并入栈，方法结束时出栈。栈帧中包含储存着局部变量表（包含基本数据类型、对象引用、返回地址）、操作栈、动态链接、方法出口

* 本地方法栈：执行Native方法的区域

* Java堆：线程共享，储存对象实例。

* 方法区：线程共享，储存已经被加载的类信息、常量、静态变量、及时编译器编译后的代码

* 运行时常量池：方法区的一部分，储存编译期的字面量和符号引用以及运行时的新常量，如String.intern()

* 直接内存：不属于数据区；NIO可以通过Native函数直接分配堆外内存





### 2、对象访问

Object obj = new Object();

Object obj 会反应在虚拟机栈中的本地变量表中

new Object()会在Java堆中会**根据方法区的类、接口信息等等**新建一个Object对象。

![Hotspot指针访问对象](/Users/zhou/Documents/文档/准备/Java基础/JVM/img/Hotspot指针访问对象.jpg)



### 3、内存异常

| 异常类型       | 数据区                  | 重现方式                                    |
| -------------- | ----------------------- | ------------------------------------------- |
| OutOfMemory    | Java堆                  | 不断地新建对象                              |
| OutOfMemory    | 虚拟机栈/本地方法栈溢出 |                                             |
| OutOfMemory    | 运行时常量池溢出        | 通过String.intern()不断地向常量池中加入对象 |
| OutOfMemory    | 方法区溢出              | 通过CGlib或者动态代理创建类。               |
| OutOfMemory    | 本机直接内存溢出        |                                             |
|                |                         |                                             |
| Stack Overflow | 虚拟机栈                | 不断递归                                    |





## 二、垃圾回收以及内存分配

### 1、垃圾回收算法

根搜索算法：当一个对象没有引用链指向GC Roots，则该对象是不可用的。

可以作为GC Roots：

1. 虚拟机栈中本地变量表引用的对象
2. 方法区类静态属性引用的对象
3. 方法区类常量引用的对象
4. 本地方法栈引用的对象



### 2、对象的引用

1. 强引用：只要引用存在，GC就不会清理掉
2. 软引用：当内存不够时触发GC，软引用会被清理
3. 弱引用：下一次GC时会被清理
4. 虚引用：对生存时间无影响，只用于得到系统回收时的提示

当对象将要被清除时会触发其finalize()方法，如果在finalize方法中将自身与GC Roots相连，则可以避免被清除。

但是finalize方法只会被**触发一次**，下次清除时不会触发finalize方法。



### 3、垃圾收集算法

| 算法名称      | 清除过程                                                     | 缺点                     | 备注                                                         |
| ------------- | ------------------------------------------------------------ | ------------------------ | ------------------------------------------------------------ |
| 标记-清除算法 | 标记所有需要回收的对象，并将其清除                           | 回收的内存不连续         |                                                              |
| 复制算法      | 将内存分为大小相同的两块，当需要清理时，将还存活的对象转移到另一部分，之后将原内存清理 | 内存只有原来一半可以使用 | 大部分新生代都要被清理，所以无需按照1：1分配空间             |
| 标记-整理算法 | 在执行标记后，将所有存活的对象移向内存的一端，之后清除掉存活边界外的内存空间。 |                          | 因为老年代存活率很高，所以复制算法代价很高，才出现了标记-整理算法 |
| 分代收集算法  | 根据对象存活的时间长短，将内存划为几部分，新生代及老年代。不同代使用不同的算法。 |                          | 新生代使用复制算法，老年代使用标记整理算法                   |



复制算法在新生代的应用：

<img src="/Users/zhou/Documents/文档/准备/Java基础/JVM/img/新生代复制算法.jpg" alt="新生代复制算法"  />

**新生代采用Eden：fromSurvivor：toSurvivor=8：1：1的比例**



### 4、垃圾收集器

* 并发垃圾收集和并行垃圾收集的区别

  并行：指多个垃圾收集线程同时运行，用户线程仍然处于等待状态

  并发：指垃圾收集线程和用户线程同时执行

  

* Minor GC和Full GC的区别

  Minor GC：新生代GC，指发生在新生代的垃圾收集动作。 因为Java对象大多是朝生夕灭，所以Minor GC非常频繁，一般回收速度也比较快。

  Full GC：老年代GC，指发生在老年代的GC。Major GC速度一般比Minor GC慢10倍以上。

  

| 收集器名称                         | 使用年代       | 工作方式                                                     | 备注              |
| ---------------------------------- | -------------- | ------------------------------------------------------------ | ----------------- |
| Serial收集器                       | 新生代         | 单线程收集 工作时会停止其他所有工作线程（Stop The World）复制算法 | 对于单核简单高效  |
| ParNew收集器                       | 新生代         | 多线程版的Serial收集器                                       | 适用于交互        |
| Parallel Scavenge收集器            | 新生代         | 和ParNew相同。侧重点为吞吐量，高效利用CPU                    | 适用于后台计算    |
| Serial Old收集器                   | 老年代         | 单线程收集，使用标记-整理算法                                | 作为CMS的后备方案 |
| Parallel Old收集器                 | 老年代         | Parallel Scavenge的老年代版                                  |                   |
| CMS收集器（Concurrent Mark Sweep） | 老年代         | 以最短回收停顿时间为目标，使用标记-清除算法。                |                   |
| G1收集器（Garbage First）          | 新生代、老年代 | 标记-整理，可以精确地控制停顿。把新生代、老年代分为多个区域，自身维护着一个优先列表，根据允许收集的时间，优先回收垃圾最多的区域 |                   |

* CMS收集器清理过程

  1、初始标记：单线程标记GC Roots直接关联的对象。**stop the world**

  2、并发标记：多线程对初始标记的对象，进行GC Roots Tracing

  3、重新标记：修正并发标记期间，因用户程序运行导致变化的部分标记。**stop the world**

  4、并发清除：并发清理需要清理的对象

  由于CMS采用标记-清除所以会产生内存碎片，可以通过参数指定执行多少次GC后进行内存压缩

* 浮动垃圾和Concurrent Mode Failure

  1、浮动垃圾：在进行垃圾清理时用户线程产生的垃圾。

  2、Concurrent Mode Failure：因为浮动垃圾，所以在清理前需预留出一部分空间，如果空间不足，会报这个错误，同时启用Serial Old垃圾收集器作为此次GC的后备方案



### 5、更详细的参考

[GC调优以及G1和CMS](https://juejin.im/post/5b6b986c6fb9a04fd1603f4a)





