# 						Java内存模型与并发

## 一、内存模型

* 所有变量都存在主内存中
* 每条线程有自己的工作内存，在工作内存中储存了线程使用到的工作内存的变量副本，所有读取、赋值都是在工作内存中进行，再拷贝到主内存中。
* 不同线程之间不能互相访问，只能通过主内存进行传递

##### **主内存近似于Java堆的对象部分，工作内存对应虚拟机栈的部分**

##### 主内存近似于硬件中的内存，工作内存对应寄存器和高速缓存

**CAS：Compare And Swap 虚拟机保证的内存原子操作，是一个乐观锁。**

**CAS机制当中使用了3个基本操作数：内存地址V，旧的预期值A，要修改的新值B。更新一个变量的时候，只有当变量的预期值A和内存地址V当中的实际值相同时，才会将内存地址V对应的值修改为B。**



## 二、Volatile

#### 多线程存在的问题：

* 因为线程间交互通过主存，所以线程A的读取操作要在线程B的回写操作结束后，才会得到最新值。
* CPU为了提高执行效率，会将指令进行重排序优化。

#### Volatile解决的问题

1. 保证变量的可见性。Volatile变量在一个线程中修改后，会立刻同步到其他线程。
2. 防止指令重排序优化，

#### 什么时候可以使用volatile

1. 运行结果不依赖变量当前值，或只有一个线程对变量进行写操作，别的线程都进行读操作。
2. 运算中不依赖其他可变变量



## 三、内存模型特性

### 1、原子性

* 6个原子性变量操作，基本类型数据的读写具备原子性(虚拟机规范32位必须实现原子性，所以long和double在极少的虚拟机中读写无原子性)

  | read                 | load                   | use                        | assign                       | store                    | write             | lock                             | unlock                         |
  | -------------------- | ---------------------- | -------------------------- | ---------------------------- | ------------------------ | ----------------- | -------------------------------- | ------------------------------ |
  | 主内存传输到工作内存 | read后写入工作内存副本 | 工作内存变量值传给执行引擎 | 工作内存变量接收执行引擎的值 | 将工作内存变量传给主内存 | store后写入主内存 | 将主内存的变量表示为一条线程独占 | 将主内存中的变量从锁定状态释放 |

* 可以通过synchronized将多条语句合并成一条原子操作

### 2、可见性

* volatile 变量修改后会同步到其他线程
* synchronized  对一个变量unlock前，必须将其同步到主内存（执行store和write）
* final  当final正确初始化，所有线程读取到的都是同样的值。**保证在构造器不将this引用传递到新的线程（比如在构造器中创建线程）**

### 3、有序性

* volatile 禁止指令重排序
* synchronized 保证同步块中同时只能由一个线程访问



## 四、Synchronized

* 通过synchronized将多条语句合并成一条原子操作
* synchronized  对一个变量unlock前，必须将其同步到主内存（执行store和write）
* 在一个线程释放锁后，即synchronized结束后，另一个线程才能读取到它所更改的信息。
* synchronized 保证同步块中同时只能由一个线程访问

##### synchronized原理

* Java内存模型提供了unlock和lock，在更高层次的字节码通过monitorenter和monitorexit对对象进行锁定。

* synchronized同步块前后会形成monitorenter，monitorexit两个字节码。
* 执行monitorenter指令，如果对象没有被锁定，则获取对象的锁，且计数器+1。执行monitorexit指令，计数器-1，当计数器=0时，锁被释放。
* synchronized对于自身是可重入的，同时只有一个线程能够对它进行访问，其他线程会被阻塞。



## 五、锁优化

### 1、自旋锁

避免线程阻塞，导致频繁在内核态和用户态频繁切换，虚拟机会让等待的线程执行循环（自旋），如果在一定时间内没有获得对象锁，线程就会挂起，相当于白白消耗了处理器性能。如果获得了锁，那么当下一次获取同一对象的锁时，会等待更长的时间。

### 2、锁消除

虚拟机分析出一段代码只在一个线程中执行，会将这段代码中的锁去掉。分析的主要依据是逃逸分析技术

### 3、锁粗化

虚拟机分析出一连串的操作都对同一个对象加锁，虚拟机会把加锁同步的范围扩展至操作外部，这样只需加锁一次。

### 4、轻量级锁

​		加锁过程：通过更改对象头中的MarkWord，标识对象是否被锁，如果没有被锁，就将MarkWord拷贝到线程栈空间，并通过CAS机制将MarkWord标识为“轻量锁”，更改成功则线程拥有了当前对象的锁；如果没有标识轻量锁成功，则会判断当前锁是否为当前线程加上的，如果是当前线程加上的，则直接进入锁，否则膨胀为重量级锁。

​		解锁过程：通过CAS机制将线程中的MarkWord重新拷贝到MarkWord。如果没有成功，说明有其他的线程在请求对象锁，在释放锁的同时，也要唤醒等待的线程。

​		如果在占用期间没有其他线程请求锁定对象的锁，则**省去了锁定对象的开销**。理论依据：***对于大部分的锁，在同步周期内不存在竞争***



### 5、偏向锁

​		通过更改对象头中的MarkWord，标识占用对象的线程id，如果对象一直被同一个线程占用，相对于轻量级锁省去了拷贝信息的时间。如果对象锁被另一个线程请求，则偏向锁膨胀为轻量级锁。



## 六、 Synchronized和ReentrantLock异同

### 异：

使用层面

ReentrantLock可以作为对象传入。

功能层面

1. synchronized非公平，ReentrantLock都可以；
2. synchronize不可中断，ReentrantLock可中断；

