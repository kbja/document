

# 									索引

## 一、索引类型

Mysql的索引都是通过B+Tree实现的，不存在Hash的索引。Hash的索引不支持范围、后置like查询。

### 1、聚簇索引

* 覆盖索引大部分为id主键，如果没有主键，则是非空唯一（联合）索引。
* 一张表只能有一个聚簇索引
* 结构为B+Tree，在叶子节点储存数据信息；非叶节点储存的是主键值。



### 2、非聚簇索引（二级索引）

* 非聚簇索引叶子节点只存了这条数据聚簇索引的地址，所以当通过非聚簇索引查询时，需要对非聚簇索引和聚簇索引两棵B+Tree进行遍历。

***问题：联合索引的B+Tree结构是什么样的***

[感觉这个解答有错误，但是相比单一字段索引，避免了回表查询，待确认](https://www.cnblogs.com/wuchanming/p/9185661.html)

[和上面那个解答类似](https://blog.csdn.net/q6627666/article/details/104405461)

### 3、覆盖索引

**不是一种索引**，而是说明select、join和where中所用到的字段都包含在索引中，不需要回表查询。



## 二、创建索引

* 区分度要高，count(index)/count(*)越大越好。
* 选择where中选择度高的字段，选择度越高越靠前。
* 如果单条数据很大，却需要做索引，可以做前置索引。取数据的前n位，只要n位有很大的区分度即可。如果区分度不大，可以把数据倒置，做后置索引。（mysql原生不支持）
* 不要建过多的索引。1、每次查询只能使用一个索引；2、插入、更新时要维护索引。

## 三、查询优化

1. 最左匹配原则。联合索引a,b,c，mysql会先匹配where语句中a，如果有a会匹配a,b再去匹配a,b,c；如果a不存在，则不会使用索引。

   原因：B+Tree的结构

   注意：如果where中联合索引使用or相连，则不会使用索引进行查询。可使用Union解决。

   如果WHERE语句中包含索引项，但是不符合最左匹配原则，mysql的查询优化器会将其按照索引顺序优化。

2. 使用独立的列，不要参与计算。

```mysql
select * from table where id + 1 = 5;
select * from table where Year(update_time)=2019
```



