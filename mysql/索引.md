

# 									索引

## 一、索引类型

Mysql InnoDB的索引都是通过B+Tree实现的，不存在Hash的索引。Hash的索引不支持范围、后置like查询。

### 1、聚簇索引

* 覆盖索引大部分为id主键，如果没有主键，则是非空唯一（联合）索引。
* 一张表只能有一个聚簇索引
* 结构为B+Tree，在叶子节点储存数据信息；非叶节点储存的是主键值。



### 2、非聚簇索引（二级索引）

* 非聚簇索引叶子节点只存了这条数据聚簇索引的地址，所以当通过非聚簇索引查询时，需要对非聚簇索引和聚簇索引两棵B+Tree进行遍历。

***问题：联合索引的B+Tree结构是什么样的***

[感觉这个解答有错误，但是相比单一字段索引，避免了回表查询，待确认](https://www.cnblogs.com/wuchanming/p/9185661.html)

[和上面那个解答类似](https://blog.csdn.net/q6627666/article/details/104405461)

### 3、覆盖索引

**不是一种索引**，而是说明select、join和where中所用到的字段都包含在索引中，不需要回表查询。



## 二、创建索引

* 区分度要高，count(index)/count(*)越大越好。
* 选择where中选择度高的字段，选择度越高越靠前。
* 如果单条数据很大，却需要做索引，可以做前置索引。取数据的前n位，只要n位有很大的区分度即可。如果区分度不大，可以把数据倒置，做后置索引。（mysql原生不支持）
* 不要建过多的索引。1、每次查询只能使用一个索引；2、插入、更新时要维护索引。

## 三、查询优化

1. 最左匹配原则。联合索引a,b,c，mysql会先匹配where语句中a，如果有a会匹配a,b再去匹配a,b,c；如果a不存在，则不会使用索引。

   原因：B+Tree的结构

   注意：如果where中联合索引使用or相连，则不会使用索引进行查询。可使用Union解决。

   如果WHERE语句中包含索引项，但是不符合最左匹配原则，mysql的查询优化器会将其按照索引顺序优化。

2. 使用独立的列，不要参与计算。

```mysql
select * from table where id + 1 = 5;
select * from table where Year(update_time)=2019
```



## 四、B树和B+树

##### 为什么MySQL选择B+树做索引

1、 **B+树的磁盘读写代价更低**：B+树的内部节点并没有指向关键字具体信息的指针，因此其内部节点相对B树更小，如果把所有同一内部节点的关键字存放在同一盘块中，那么盘块所能容纳的关键字数量也越多，一次性读入内存的需要查找的关键字也就越多，相对IO读写次数就降低了。

2、**B+树的查询效率更加稳定**：由于非终结点并不是最终指向文件内容的结点，而只是叶子结点中关键字的索引。所以任何关键字的查找必须走一条从根结点到叶子结点的路。所有关键字查询的路径长度相同，导致每一个数据的查询效率相当。

3、**B+树更便于遍历**：由于B+树的数据都存储在叶子结点中，分支结点均为索引，方便扫库，只需要扫一遍叶子结点即可，但是B树因为其分支结点同样存储着数据，我们要找到具体的数据，需要进行一次中序遍历按序来扫，所以B+树更加适合在区间查询的情况，所以通常B+树用于数据库索引。

4、**B+树更适合基于范围的查询**：B树在提高了IO性能的同时并没有解决元素遍历的我效率低下的问题，正是为了解决这个问题，B+树应用而生。B+树只需要去遍历叶子节点就可以实现整棵树的遍历。而且在数据库中基于范围的查询是非常频繁的，而B树不支持这样的操作或者说效率太低。

